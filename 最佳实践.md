1) 解耦 HTML/JavaScript 
一般来说，你应该避免在JavaScript中创建大量HTML。再一次重申要保持层次的分离，这样可以很容易的确定错误来源。

HTML 呈现应该尽可能与JavaScript保持分离。当JavaScript用于插入数据时，尽量不要直接插入标记。一般可以在页面中直接包含并隐藏标记，然后等到整个页面渲染好之后，就可以用 JavaScript 显示该标记，而非生成它。

另一种方法是进行 Ajax请求并获取更多要显示的HTML，这个方法可以让同样的渲染层（PHP、JSP、Ruby 等等）来输出标记，而不是直接嵌在JavaScript中。将HTML和JavaScript解耦可以在调试过程中节省时间，更加容易确定错误的来源，也减轻维护的难度：更改行为只需要在JavaScript文件中进行，而更改标记则只要在渲染文件中。

2) 解耦 CSS/JavaScript 

        //CSS 对 JavaScript 的紧密耦合
        element.style.color = "red";
        element.style.backgroundColor = "blue"; 
        
        //CSS 对 JavaScript 的松散耦合
        element.className = "edit";
        
3) 解耦应用逻辑／事件处理程序

较好的方法是将应用逻辑和事件处理程序相分离，这样两者分别处理各自的东西。一个事件处理程序应该从事件对象中提取相关信息，并将这些信息传送到处理应用逻辑的某个方法中。

以下是要牢记的应用和业务逻辑之间松散耦合的几条原则：
* 勿将 event 对象传给其他方法；只传来自 event 对象中所需的数据；
* 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行；
* 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑。
牢记这几条可以在任何代码中都获得极大的可维护性的改进，并且为进一步的测试和开发制造了很
多可能。

4) 性能

1.1 注意作用域
  
  1-1避免全局查找 
  
    function updateUI(){
        var imgs = document.getElementsByTagName("img");
        for (var i=0, len=imgs.length; i < len; i++){
            imgs[i].title = document.title + " image " + i;
        }
        var msg = document.getElementById("msg");
        msg.innerHTML = "Update complete.";
    }
    
该函数可能看上去完全正常，但是它包含了三个对于全局document对象的引用。如果在页面上有多个图片，那么for循环中的document引用就会被执行多次甚至上百次，每次都会要进行作用域链查找。
  
    function updateUI(){
        var doc = document;
        var imgs = doc.getElementsByTagName("img");
        for (var i=0, len=imgs.length; i < len; i++){
            imgs[i].title = doc.title + " image " + i;
        }
        var msg = doc.getElementById("msg");
        msg.innerHTML = "Update complete.";
    }
    
这里，首先将 document 对象存在本地的 doc 变量中；然后在余下的代码中替换原来的 document。与原来的的版本相比，现在的函数只有一次全局查找，肯定更快。


1.2 避免 with 语句 

和函数类似，with 语句会创建自己的作用域，因此会增加其中执行的代码的作用域链的长度。由于额外的作用域链查找，在with语句中执行的代码肯定会比外面执行的代码要慢。

2 选择正确方法

2.1 避免不必要的属性查找 

使用变量和数组要比访问对象上的属性更有效率，后者是一个O(n)操作。对象上的任何属性查找都要比访问变量或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。

2.2 优化循环 

2.3 展开循环 

2.4 避免双重解释

    //某些代码求值——避免!!
    eval("alert('Hello world!')");
    //创建新函数——避免!!
    var sayHi = new Function("alert('Hello world!')");
    //设置超时——避免!!
    setTimeout("alert('Hello world!')", 500); 
    
2.5 性能的其他注意事项

* 原生方法较快
* Switch 语句较快
* 位运算符较快
 
3 最小化语句数 

3.1 多个变量声明 

    //一个语句
    var count = 5,
     color = "blue",
     values = [1,2,3],
     now = new Date(); 
     
3.2 插入迭代值 

    var name = values[i++]; 

3.3 使用数组和对象字面量

    //只用一条语句创建和初始化数组
    var values = [123, 456, 789];
    //只用一条语句创建和初始化对象
    var person = {
        name : "Nicholas",
        age : 29,
        sayName : function(){
            alert(this.name);
        }
    }; 

4 优化DOM交互

4.1 最小化现场更新 

    var list = document.getElementById("myList"),
        fragment = document.createDocumentFragment(),
        item,
        i;
    for (i=0; i < 10; i++) {
        item = document.createElement("li");
        fragment.appendChild(item);
        item.appendChild(document.createTextNode("Item " + i));
    }
    list.appendChild(fragment);
    
在这个例子中只有一次现场更新，它发生在所有项目都创建好之后。文档片段用作一个临时的占位符，放置新创建的项目。然后使用appendChild()将所有项目添加到列表中。记住，当给 appendChild()传入文档片段时，只有片段中的子节点被添加到目标，片段本身不会被添加的。 

4.2 使用 innerHTML 

当把 innerHTML 设置为某个值时，后台会创建一个 HTML 解析器，然后使用内部的 DOM 调用来创建 DOM 结构，而非基于JavaScript的DOM调用。由于内部方法是编译好的而非解释执行的，所以执行快得多。

    var list = document.getElementById("myList"),
        html = "",
        i;
    for (i=0; i < 10; i++) {
        html += "<li>Item " + i + "</li>";
    }
    list.innerHTML = html; 
    
    
    //避免以下
    var list = document.getElementById("myList"),
        i;
    for (i=0; i < 10; i++) {
        list.innerHTML += "<li>Item " + i + "</li>"; //避免!!!
    } 

4.3 使用事件代理

4.4 注意 HTMLCollection 

    var images = document.getElementsByTagName("img"),
        image,
        i, len;
    for (i=0, len=images.length; i < len; i++){
        image = images[i];
        //处理
    }
    
这段代码添加了 image 变量，保存了当前的图像。这之后，在循环内就没有理由再访问 images 的HTMLCollection 了 。

部署

将代码分离成多个文件只是为了提高可维护性，并非为了部署。要进行部署的时候，需要将这些源代码合并为一个或几个归并文件。推荐Web应用中尽可能使用最少的JavaScript 文件，是因为 HTTP请求是 Web中的主要性能瓶颈之一。记住通过<script>标记引用 JavaScript文件是一个阻塞操作，当代码下载并运行的时候会停止其他所有的下载。因此，尽量从逻辑上将 JavaScript 代码分组成部署文件。

* 验证 
* 压缩 
* 文件压缩 
*  HTTP 压缩
